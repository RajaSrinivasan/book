
\documentclass[12pt, a4paper]{article} 


\usepackage{booktabs} % Horizontal rules in tables 
% For generating tables, use “LaTeX” online generator (https://www.tablesgenerator.com)
\usepackage{comment} % Necessary to comment several paragraphs at once
\usepackage[utf8]{inputenc} % Required for international characters
\usepackage[T1]{fontenc} % Required for output font encoding for international characters
\usepackage{listings}
\usepackage{tcolorbox}

\colorlet{shadecolor}{orange!15}
\lstset{basicstyle=\linespread{0.8}\ttfamily\footnotesize,
    xleftmargin=0.7cm,
    frame=tlbr, framesep=0.2cm, framerule=0pt,
}
\lstset{frame=single}

% Might be helpful
\usepackage{amsmath,amsfonts,amsthm} % Math packages which might be useful for equations
\usepackage{tikz} % For tikz figures (to draw arrow diagrams, see a guide how to use them)
\usepackage{tikz-cd}
\usetikzlibrary{positioning,arrows} % Adding libraries for arrows
\usetikzlibrary{decorations.pathreplacing} % Adding libraries for decorations and paths
\usepackage{tikzsymbols} % For amazing symbols ;) https://mirror.hmc.edu/ctan/graphics/pgf/contrib/tikzsymbols/tikzsymbols.pdf 
\usepackage{blindtext} % To add some blind text in your paper

\usepackage{url}
\usepackage{enumerate}
\usepackage{setspace}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} 
\usepackage{XCharter} 
\usepackage{fancyhdr} 
\usepackage{geometry}

\geometry{
	top=1cm, % Defines top margin
	bottom=2cm, % Defines bottom margin
	left=2.2cm, % Defines left margin
	right=2.2cm, % Defines right margin
	includehead, % Includes space for a header
	includefoot, % Includes space for a footer
	%showframe, % Uncomment if you want to show how it looks on the page 
}
\setlength{\headheight}{15pt}
\setlength{\parindent}{15pt} 

\linespread{1}

\pagestyle{fancy} % Allows you to customize the headers and footers
\lhead{} 
\chead{\textit{Code Markdown}} % Define center header - e.g. add your paper title
\rhead{} 

% Footers
\lfoot{codemd v0.1} % Define left footer
\rfoot{\footnotesize Page \thepage} 
\cfoot{ } % Define right footer

\title{codemd - Code markdown for authoring}

\begin{document}

 % Adds your title
\author{Srini}
\date{\small \today} 
\maketitle
\section{Introduction}

Text processing - including searching and manipulating text is an essential element of many applications. User interfaces require support for validating phone numbers, postal codes and the like. Regular Expressions are the swiss army knife of text processing. Ability to exploit these is an essential software engineering skill. Most programming languages have libraries
supporting regular expressions.

\paragraph{} In this projectlet, we explore regular expressions, in the process building a helper application. Authors of software documents need a way to include code examples. A simple markup language is designed to extract code snippets to enable inclusion in documents.

\subsection{Projectlet Overview}
The requirement for codemd is to process source files embedding markup commands to generate latex files that can be included in other documents.

\section{Code markup language}
Code is marked up with directives introduced by the keyword codemd:. Since codemd ignores all other markers, it is language agnostic. Directives are included in line comments appropriate for the language (Eg. \# for Python and – for Ada).
\begin{itemize}

    \item \textbf{begin} Starts an illustrative section. Creates a tex file. Options for this directive are:
    \begin{itemize}
        \item \textbf{section=name} provides a name for this fragment of code. Used as part of the filename generated.
        \item \textbf{caption=”string”} provides a name for the caption.
        \item \textbf{language=language} - can be used to specify the programming language. Default is Ada. This is used to request an appropriate language sensitive markup in the output.
        \item \textbf{end} Ends the illustrative section. Closes the file created earlier. There is an implicit end at the end of the file.
    \end{itemize}
\item \textbf{skip} Very long procedures with a lot of details not relevant to a discussion could be eliminated from the output by using the skip directive. Any code fragments between skip and end skip will not be emitted but replaced by an ellipsis.

\item \textbf{end skip} terminates a skip block.
\end{itemize}

\subsection{Markup}
\begin{verbatim}
--codemd: begin segment=Show caption=Show Command Line Argument 
procedure ShowCommandLineArguments is
begin
Put ("Verbose ");
Put (Verbose);
New_Line;
end ShowCommandLineArguments;
-- codemd: end
\end{verbatim}
\subsection{Generated tex file}

\begin{verbatim}
\lstset{language=Ada, caption=Show Command Line Argument}
\begin{lstlisting}[frame=single, numbers=left, numbersep=5pt, firstnumber= 54]
procedure ShowCommandLineArguments is
begin
Put ("Verbose ");
Put (Verbose);
New_Line;
end ShowCommandLineArguments;
\end{lstlisting}
\end{verbatim}

\subsection{Including the generated output}
The output generated assumes an environment - typically setup as follows:

\begin{verbatim}
\usepackage{listings}
\usepackage{tcolorbox}
\end{verbatim}

The file itself is included using the input command as follows:

\begin{verbatim}
\input{fragment.tex}
\end{verbatim}

The effect of the above is to include a fragment of code extracted from the original source file, each line numbered with respect to the source file.

\section{Implementation}
\subsection{Source Line Analysis}
The key learning objective of this projectlet being regular expressions, we start with strategizing 
source code analysis. 
For the typical Ada environment, the predefined library includes the following options:

\begin{itemize}
    \item GNAT.Regexp - suitable for entire words as in file names, phone numbers
and the like.

    \item GNAT.Regpat - more versatile support including extracting values from
a string.

    \item GNAT.Spitbol - a complete implementation equivalent to SPITBOL.

\end{itemize}

For our current application, GNAT.Regpat will be most suitable since we will not be 
concerned with entire lines - instead searching for the presence of specific patterns 
but potentially including other text as part of the line. 

This enables the markup be language agnostic - as long as there is support for 
single line comments. For example C++ with // or python with \# as the comment leaders can be easily be handled by the codemd markup.

\subsection{The regular expression patterns}

The markup outlined above is translated to patterns as below: 
\input{impl-patterns.tex}

Line 17 is the simplest pattern recognizing the end directive. The pattern indicates that the keywords codemd: and end can be separated by one or more spaces. Likewise recognizing skip is straightforward and very similar. These patterns are simple enough that we could have used basic string searches if we settle for a strict syntax of exactly 1 space between the keywords.

Line 21 recognizes the end skip directives.

It can be recognized that a line that matches the end skip directive will also match the end directive. Thus we have to check for the longer pattern first before attempting to match the shorter pattern.

Line 12 recognizes a more complex pattern which has user data embedded in keywords. For example, section and caption have values that have to be extracted. The values for section and caption can be of arbitrary lengths and use arbitrary sequences of letters and numbers. The inclusion of subpatterns inside parentheses is the technique to extract the user specified values.

\subsection{File processing}
\input{impl-main.tex}

While regular expressions are the workhorse of this effort, 
simple searches have their role. The main processing of the source file 
illustrated below utilizes a basic search in line 134 to determine whether 
this line is a potential starter for a marked up segment.

Once it is detected that a segment is to be started, the entire segment is processed by a separate procedure as in the line 136. The entire logic is rendered fairly understandable by delegating responsibilities to other procedures or functions.

\subsection{Extract the code segments}
The segment recognition starts with confirming that the specifications are complete and extracting the user supplied parameters.
\input{impl-beginpat.tex}

Lines 44 and 45 attempt to match the line with the expected syntax, in the process extracting the segment name and the Caption. If the line is not syntactically complete the extraction process is abandoned.

The extracted values are printed out in lines 51-54.

\subsection{Segment skipping}
\input{impl-skip.tex}

\section{Summary}

This projectlet demonstrated the application of regular expressions to produce a tool that supports authors. The output of this tool is in a form compatible with \textbf{tex}. We can also generate a more compatible graphical form such as \textbf{png} as demonstrated in a parallel \textbf{C++} project. The ability to 
link disparate applications with moderate tooling effort is a valuable skill
for any professional software engineer.

\subsection{Next steps}

The techniques learned here will fit in any number of projects such as:

\begin{itemize}
    \item \textbf{Multilingual applications} - a tool to process a \textbf{C} header file and create say a \textbf{Ada} equivalence for enumerations or 
    add \textbf{Ada} like support in \textbf{C} can be built to great benefit.
    \item \textbf{json, yaml, toml} have pretty much overtaken earlier formats
    such as \textbf{ini} and \textbf{xml} as the method of choice for storing configuration options. Being able to comfortably read and write configuration items in these formats will enable an application to evolve at a convenient pace.
    \item \textbf{Internationalization} - needs a way to enable applications not to
    hardcode messages, depending on message codes instead. Practically however the eearly stages of an application development effort cannot afford the overhead. A tool that can extract strings to be replaced by a code that can at runtime be replaced by the string is a good first step.
\end{itemize}

\subsection{Example Implementation}

\fbox{%   
    \parbox{30em}{%
    Implementation in \textbf{Ada} \url{https://gitlab.com/ada23/codemd.git}
    }   
}

\end{document}